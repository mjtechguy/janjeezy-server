// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package gormgen

import (
	"context"
	"database/sql"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"menlo.ai/indigo-api-gateway/app/infrastructure/database/dbschema"
)

func newResponse(db *gorm.DB, opts ...gen.DOOption) response {
	_response := response{}

	_response.responseDo.UseDB(db, opts...)
	_response.responseDo.UseModel(&dbschema.Response{})

	tableName := _response.responseDo.TableName()
	_response.ALL = field.NewAsterisk(tableName)
	_response.ID = field.NewUint(tableName, "id")
	_response.CreatedAt = field.NewTime(tableName, "created_at")
	_response.UpdatedAt = field.NewTime(tableName, "updated_at")
	_response.DeletedAt = field.NewField(tableName, "deleted_at")
	_response.PublicID = field.NewString(tableName, "public_id")
	_response.UserID = field.NewUint(tableName, "user_id")
	_response.ConversationID = field.NewUint(tableName, "conversation_id")
	_response.PreviousResponseID = field.NewString(tableName, "previous_response_id")
	_response.Model = field.NewString(tableName, "model")
	_response.Status = field.NewString(tableName, "status")
	_response.Input = field.NewString(tableName, "input")
	_response.Output = field.NewString(tableName, "output")
	_response.SystemPrompt = field.NewString(tableName, "system_prompt")
	_response.MaxTokens = field.NewInt(tableName, "max_tokens")
	_response.Temperature = field.NewFloat64(tableName, "temperature")
	_response.TopP = field.NewFloat64(tableName, "top_p")
	_response.TopK = field.NewInt(tableName, "top_k")
	_response.RepetitionPenalty = field.NewFloat64(tableName, "repetition_penalty")
	_response.Seed = field.NewInt(tableName, "seed")
	_response.Stop = field.NewString(tableName, "stop")
	_response.PresencePenalty = field.NewFloat64(tableName, "presence_penalty")
	_response.FrequencyPenalty = field.NewFloat64(tableName, "frequency_penalty")
	_response.LogitBias = field.NewString(tableName, "logit_bias")
	_response.ResponseFormat = field.NewString(tableName, "response_format")
	_response.Tools = field.NewString(tableName, "tools")
	_response.ToolChoice = field.NewString(tableName, "tool_choice")
	_response.Metadata = field.NewString(tableName, "metadata")
	_response.Stream = field.NewBool(tableName, "stream")
	_response.Background = field.NewBool(tableName, "background")
	_response.Timeout = field.NewInt(tableName, "timeout")
	_response.User = field.NewString(tableName, "user")
	_response.Usage = field.NewString(tableName, "usage")
	_response.Error = field.NewString(tableName, "error")
	_response.CompletedAt = field.NewTime(tableName, "completed_at")
	_response.CancelledAt = field.NewTime(tableName, "cancelled_at")
	_response.FailedAt = field.NewTime(tableName, "failed_at")
	_response.Items = responseHasManyItems{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Items", "dbschema.Item"),
		Conversation: struct {
			field.RelationField
			User struct {
				field.RelationField
				Organizations struct {
					field.RelationField
				}
				Projects struct {
					field.RelationField
				}
			}
			Workspace struct {
				field.RelationField
				User struct {
					field.RelationField
				}
				Conversations struct {
					field.RelationField
				}
			}
			Items struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Items.Conversation", "dbschema.Conversation"),
			User: struct {
				field.RelationField
				Organizations struct {
					field.RelationField
				}
				Projects struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Items.Conversation.User", "dbschema.User"),
				Organizations: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Items.Conversation.User.Organizations", "dbschema.OrganizationMember"),
				},
				Projects: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Items.Conversation.User.Projects", "dbschema.ProjectMember"),
				},
			},
			Workspace: struct {
				field.RelationField
				User struct {
					field.RelationField
				}
				Conversations struct {
					field.RelationField
				}
			}{
				RelationField: field.NewRelation("Items.Conversation.Workspace", "dbschema.Workspace"),
				User: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Items.Conversation.Workspace.User", "dbschema.User"),
				},
				Conversations: struct {
					field.RelationField
				}{
					RelationField: field.NewRelation("Items.Conversation.Workspace.Conversations", "dbschema.Conversation"),
				},
			},
			Items: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Items.Conversation.Items", "dbschema.Item"),
			},
		},
		Response: struct {
			field.RelationField
			UserEntity struct {
				field.RelationField
			}
			Conversation struct {
				field.RelationField
			}
			Items struct {
				field.RelationField
			}
		}{
			RelationField: field.NewRelation("Items.Response", "dbschema.Response"),
			UserEntity: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Items.Response.UserEntity", "dbschema.User"),
			},
			Conversation: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Items.Response.Conversation", "dbschema.Conversation"),
			},
			Items: struct {
				field.RelationField
			}{
				RelationField: field.NewRelation("Items.Response.Items", "dbschema.Item"),
			},
		},
	}

	_response.UserEntity = responseBelongsToUserEntity{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("UserEntity", "dbschema.User"),
	}

	_response.Conversation = responseBelongsToConversation{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Conversation", "dbschema.Conversation"),
	}

	_response.fillFieldMap()

	return _response
}

type response struct {
	responseDo

	ALL                field.Asterisk
	ID                 field.Uint
	CreatedAt          field.Time
	UpdatedAt          field.Time
	DeletedAt          field.Field
	PublicID           field.String
	UserID             field.Uint
	ConversationID     field.Uint
	PreviousResponseID field.String
	Model              field.String
	Status             field.String
	Input              field.String
	Output             field.String
	SystemPrompt       field.String
	MaxTokens          field.Int
	Temperature        field.Float64
	TopP               field.Float64
	TopK               field.Int
	RepetitionPenalty  field.Float64
	Seed               field.Int
	Stop               field.String
	PresencePenalty    field.Float64
	FrequencyPenalty   field.Float64
	LogitBias          field.String
	ResponseFormat     field.String
	Tools              field.String
	ToolChoice         field.String
	Metadata           field.String
	Stream             field.Bool
	Background         field.Bool
	Timeout            field.Int
	User               field.String
	Usage              field.String
	Error              field.String
	CompletedAt        field.Time
	CancelledAt        field.Time
	FailedAt           field.Time
	Items              responseHasManyItems

	UserEntity responseBelongsToUserEntity

	Conversation responseBelongsToConversation

	fieldMap map[string]field.Expr
}

func (r response) Table(newTableName string) *response {
	r.responseDo.UseTable(newTableName)
	return r.updateTableName(newTableName)
}

func (r response) As(alias string) *response {
	r.responseDo.DO = *(r.responseDo.As(alias).(*gen.DO))
	return r.updateTableName(alias)
}

func (r *response) updateTableName(table string) *response {
	r.ALL = field.NewAsterisk(table)
	r.ID = field.NewUint(table, "id")
	r.CreatedAt = field.NewTime(table, "created_at")
	r.UpdatedAt = field.NewTime(table, "updated_at")
	r.DeletedAt = field.NewField(table, "deleted_at")
	r.PublicID = field.NewString(table, "public_id")
	r.UserID = field.NewUint(table, "user_id")
	r.ConversationID = field.NewUint(table, "conversation_id")
	r.PreviousResponseID = field.NewString(table, "previous_response_id")
	r.Model = field.NewString(table, "model")
	r.Status = field.NewString(table, "status")
	r.Input = field.NewString(table, "input")
	r.Output = field.NewString(table, "output")
	r.SystemPrompt = field.NewString(table, "system_prompt")
	r.MaxTokens = field.NewInt(table, "max_tokens")
	r.Temperature = field.NewFloat64(table, "temperature")
	r.TopP = field.NewFloat64(table, "top_p")
	r.TopK = field.NewInt(table, "top_k")
	r.RepetitionPenalty = field.NewFloat64(table, "repetition_penalty")
	r.Seed = field.NewInt(table, "seed")
	r.Stop = field.NewString(table, "stop")
	r.PresencePenalty = field.NewFloat64(table, "presence_penalty")
	r.FrequencyPenalty = field.NewFloat64(table, "frequency_penalty")
	r.LogitBias = field.NewString(table, "logit_bias")
	r.ResponseFormat = field.NewString(table, "response_format")
	r.Tools = field.NewString(table, "tools")
	r.ToolChoice = field.NewString(table, "tool_choice")
	r.Metadata = field.NewString(table, "metadata")
	r.Stream = field.NewBool(table, "stream")
	r.Background = field.NewBool(table, "background")
	r.Timeout = field.NewInt(table, "timeout")
	r.User = field.NewString(table, "user")
	r.Usage = field.NewString(table, "usage")
	r.Error = field.NewString(table, "error")
	r.CompletedAt = field.NewTime(table, "completed_at")
	r.CancelledAt = field.NewTime(table, "cancelled_at")
	r.FailedAt = field.NewTime(table, "failed_at")

	r.fillFieldMap()

	return r
}

func (r *response) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := r.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (r *response) fillFieldMap() {
	r.fieldMap = make(map[string]field.Expr, 39)
	r.fieldMap["id"] = r.ID
	r.fieldMap["created_at"] = r.CreatedAt
	r.fieldMap["updated_at"] = r.UpdatedAt
	r.fieldMap["deleted_at"] = r.DeletedAt
	r.fieldMap["public_id"] = r.PublicID
	r.fieldMap["user_id"] = r.UserID
	r.fieldMap["conversation_id"] = r.ConversationID
	r.fieldMap["previous_response_id"] = r.PreviousResponseID
	r.fieldMap["model"] = r.Model
	r.fieldMap["status"] = r.Status
	r.fieldMap["input"] = r.Input
	r.fieldMap["output"] = r.Output
	r.fieldMap["system_prompt"] = r.SystemPrompt
	r.fieldMap["max_tokens"] = r.MaxTokens
	r.fieldMap["temperature"] = r.Temperature
	r.fieldMap["top_p"] = r.TopP
	r.fieldMap["top_k"] = r.TopK
	r.fieldMap["repetition_penalty"] = r.RepetitionPenalty
	r.fieldMap["seed"] = r.Seed
	r.fieldMap["stop"] = r.Stop
	r.fieldMap["presence_penalty"] = r.PresencePenalty
	r.fieldMap["frequency_penalty"] = r.FrequencyPenalty
	r.fieldMap["logit_bias"] = r.LogitBias
	r.fieldMap["response_format"] = r.ResponseFormat
	r.fieldMap["tools"] = r.Tools
	r.fieldMap["tool_choice"] = r.ToolChoice
	r.fieldMap["metadata"] = r.Metadata
	r.fieldMap["stream"] = r.Stream
	r.fieldMap["background"] = r.Background
	r.fieldMap["timeout"] = r.Timeout
	r.fieldMap["user"] = r.User
	r.fieldMap["usage"] = r.Usage
	r.fieldMap["error"] = r.Error
	r.fieldMap["completed_at"] = r.CompletedAt
	r.fieldMap["cancelled_at"] = r.CancelledAt
	r.fieldMap["failed_at"] = r.FailedAt

}

func (r response) clone(db *gorm.DB) response {
	r.responseDo.ReplaceConnPool(db.Statement.ConnPool)
	r.Items.db = db.Session(&gorm.Session{Initialized: true})
	r.Items.db.Statement.ConnPool = db.Statement.ConnPool
	r.UserEntity.db = db.Session(&gorm.Session{Initialized: true})
	r.UserEntity.db.Statement.ConnPool = db.Statement.ConnPool
	r.Conversation.db = db.Session(&gorm.Session{Initialized: true})
	r.Conversation.db.Statement.ConnPool = db.Statement.ConnPool
	return r
}

func (r response) replaceDB(db *gorm.DB) response {
	r.responseDo.ReplaceDB(db)
	r.Items.db = db.Session(&gorm.Session{})
	r.UserEntity.db = db.Session(&gorm.Session{})
	r.Conversation.db = db.Session(&gorm.Session{})
	return r
}

type responseHasManyItems struct {
	db *gorm.DB

	field.RelationField

	Conversation struct {
		field.RelationField
		User struct {
			field.RelationField
			Organizations struct {
				field.RelationField
			}
			Projects struct {
				field.RelationField
			}
		}
		Workspace struct {
			field.RelationField
			User struct {
				field.RelationField
			}
			Conversations struct {
				field.RelationField
			}
		}
		Items struct {
			field.RelationField
		}
	}
	Response struct {
		field.RelationField
		UserEntity struct {
			field.RelationField
		}
		Conversation struct {
			field.RelationField
		}
		Items struct {
			field.RelationField
		}
	}
}

func (a responseHasManyItems) Where(conds ...field.Expr) *responseHasManyItems {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a responseHasManyItems) WithContext(ctx context.Context) *responseHasManyItems {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a responseHasManyItems) Session(session *gorm.Session) *responseHasManyItems {
	a.db = a.db.Session(session)
	return &a
}

func (a responseHasManyItems) Model(m *dbschema.Response) *responseHasManyItemsTx {
	return &responseHasManyItemsTx{a.db.Model(m).Association(a.Name())}
}

func (a responseHasManyItems) Unscoped() *responseHasManyItems {
	a.db = a.db.Unscoped()
	return &a
}

type responseHasManyItemsTx struct{ tx *gorm.Association }

func (a responseHasManyItemsTx) Find() (result []*dbschema.Item, err error) {
	return result, a.tx.Find(&result)
}

func (a responseHasManyItemsTx) Append(values ...*dbschema.Item) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a responseHasManyItemsTx) Replace(values ...*dbschema.Item) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a responseHasManyItemsTx) Delete(values ...*dbschema.Item) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a responseHasManyItemsTx) Clear() error {
	return a.tx.Clear()
}

func (a responseHasManyItemsTx) Count() int64 {
	return a.tx.Count()
}

func (a responseHasManyItemsTx) Unscoped() *responseHasManyItemsTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type responseBelongsToUserEntity struct {
	db *gorm.DB

	field.RelationField
}

func (a responseBelongsToUserEntity) Where(conds ...field.Expr) *responseBelongsToUserEntity {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a responseBelongsToUserEntity) WithContext(ctx context.Context) *responseBelongsToUserEntity {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a responseBelongsToUserEntity) Session(session *gorm.Session) *responseBelongsToUserEntity {
	a.db = a.db.Session(session)
	return &a
}

func (a responseBelongsToUserEntity) Model(m *dbschema.Response) *responseBelongsToUserEntityTx {
	return &responseBelongsToUserEntityTx{a.db.Model(m).Association(a.Name())}
}

func (a responseBelongsToUserEntity) Unscoped() *responseBelongsToUserEntity {
	a.db = a.db.Unscoped()
	return &a
}

type responseBelongsToUserEntityTx struct{ tx *gorm.Association }

func (a responseBelongsToUserEntityTx) Find() (result *dbschema.User, err error) {
	return result, a.tx.Find(&result)
}

func (a responseBelongsToUserEntityTx) Append(values ...*dbschema.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a responseBelongsToUserEntityTx) Replace(values ...*dbschema.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a responseBelongsToUserEntityTx) Delete(values ...*dbschema.User) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a responseBelongsToUserEntityTx) Clear() error {
	return a.tx.Clear()
}

func (a responseBelongsToUserEntityTx) Count() int64 {
	return a.tx.Count()
}

func (a responseBelongsToUserEntityTx) Unscoped() *responseBelongsToUserEntityTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type responseBelongsToConversation struct {
	db *gorm.DB

	field.RelationField
}

func (a responseBelongsToConversation) Where(conds ...field.Expr) *responseBelongsToConversation {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a responseBelongsToConversation) WithContext(ctx context.Context) *responseBelongsToConversation {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a responseBelongsToConversation) Session(session *gorm.Session) *responseBelongsToConversation {
	a.db = a.db.Session(session)
	return &a
}

func (a responseBelongsToConversation) Model(m *dbschema.Response) *responseBelongsToConversationTx {
	return &responseBelongsToConversationTx{a.db.Model(m).Association(a.Name())}
}

func (a responseBelongsToConversation) Unscoped() *responseBelongsToConversation {
	a.db = a.db.Unscoped()
	return &a
}

type responseBelongsToConversationTx struct{ tx *gorm.Association }

func (a responseBelongsToConversationTx) Find() (result *dbschema.Conversation, err error) {
	return result, a.tx.Find(&result)
}

func (a responseBelongsToConversationTx) Append(values ...*dbschema.Conversation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a responseBelongsToConversationTx) Replace(values ...*dbschema.Conversation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a responseBelongsToConversationTx) Delete(values ...*dbschema.Conversation) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a responseBelongsToConversationTx) Clear() error {
	return a.tx.Clear()
}

func (a responseBelongsToConversationTx) Count() int64 {
	return a.tx.Count()
}

func (a responseBelongsToConversationTx) Unscoped() *responseBelongsToConversationTx {
	a.tx = a.tx.Unscoped()
	return &a
}

type responseDo struct{ gen.DO }

type IResponseDo interface {
	gen.SubQuery
	Debug() IResponseDo
	WithContext(ctx context.Context) IResponseDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IResponseDo
	WriteDB() IResponseDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IResponseDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IResponseDo
	Not(conds ...gen.Condition) IResponseDo
	Or(conds ...gen.Condition) IResponseDo
	Select(conds ...field.Expr) IResponseDo
	Where(conds ...gen.Condition) IResponseDo
	Order(conds ...field.Expr) IResponseDo
	Distinct(cols ...field.Expr) IResponseDo
	Omit(cols ...field.Expr) IResponseDo
	Join(table schema.Tabler, on ...field.Expr) IResponseDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IResponseDo
	RightJoin(table schema.Tabler, on ...field.Expr) IResponseDo
	Group(cols ...field.Expr) IResponseDo
	Having(conds ...gen.Condition) IResponseDo
	Limit(limit int) IResponseDo
	Offset(offset int) IResponseDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IResponseDo
	Unscoped() IResponseDo
	Create(values ...*dbschema.Response) error
	CreateInBatches(values []*dbschema.Response, batchSize int) error
	Save(values ...*dbschema.Response) error
	First() (*dbschema.Response, error)
	Take() (*dbschema.Response, error)
	Last() (*dbschema.Response, error)
	Find() ([]*dbschema.Response, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*dbschema.Response, err error)
	FindInBatches(result *[]*dbschema.Response, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*dbschema.Response) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IResponseDo
	Assign(attrs ...field.AssignExpr) IResponseDo
	Joins(fields ...field.RelationField) IResponseDo
	Preload(fields ...field.RelationField) IResponseDo
	FirstOrInit() (*dbschema.Response, error)
	FirstOrCreate() (*dbschema.Response, error)
	FindByPage(offset int, limit int) (result []*dbschema.Response, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Rows() (*sql.Rows, error)
	Row() *sql.Row
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IResponseDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (r responseDo) Debug() IResponseDo {
	return r.withDO(r.DO.Debug())
}

func (r responseDo) WithContext(ctx context.Context) IResponseDo {
	return r.withDO(r.DO.WithContext(ctx))
}

func (r responseDo) ReadDB() IResponseDo {
	return r.Clauses(dbresolver.Read)
}

func (r responseDo) WriteDB() IResponseDo {
	return r.Clauses(dbresolver.Write)
}

func (r responseDo) Session(config *gorm.Session) IResponseDo {
	return r.withDO(r.DO.Session(config))
}

func (r responseDo) Clauses(conds ...clause.Expression) IResponseDo {
	return r.withDO(r.DO.Clauses(conds...))
}

func (r responseDo) Returning(value interface{}, columns ...string) IResponseDo {
	return r.withDO(r.DO.Returning(value, columns...))
}

func (r responseDo) Not(conds ...gen.Condition) IResponseDo {
	return r.withDO(r.DO.Not(conds...))
}

func (r responseDo) Or(conds ...gen.Condition) IResponseDo {
	return r.withDO(r.DO.Or(conds...))
}

func (r responseDo) Select(conds ...field.Expr) IResponseDo {
	return r.withDO(r.DO.Select(conds...))
}

func (r responseDo) Where(conds ...gen.Condition) IResponseDo {
	return r.withDO(r.DO.Where(conds...))
}

func (r responseDo) Order(conds ...field.Expr) IResponseDo {
	return r.withDO(r.DO.Order(conds...))
}

func (r responseDo) Distinct(cols ...field.Expr) IResponseDo {
	return r.withDO(r.DO.Distinct(cols...))
}

func (r responseDo) Omit(cols ...field.Expr) IResponseDo {
	return r.withDO(r.DO.Omit(cols...))
}

func (r responseDo) Join(table schema.Tabler, on ...field.Expr) IResponseDo {
	return r.withDO(r.DO.Join(table, on...))
}

func (r responseDo) LeftJoin(table schema.Tabler, on ...field.Expr) IResponseDo {
	return r.withDO(r.DO.LeftJoin(table, on...))
}

func (r responseDo) RightJoin(table schema.Tabler, on ...field.Expr) IResponseDo {
	return r.withDO(r.DO.RightJoin(table, on...))
}

func (r responseDo) Group(cols ...field.Expr) IResponseDo {
	return r.withDO(r.DO.Group(cols...))
}

func (r responseDo) Having(conds ...gen.Condition) IResponseDo {
	return r.withDO(r.DO.Having(conds...))
}

func (r responseDo) Limit(limit int) IResponseDo {
	return r.withDO(r.DO.Limit(limit))
}

func (r responseDo) Offset(offset int) IResponseDo {
	return r.withDO(r.DO.Offset(offset))
}

func (r responseDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IResponseDo {
	return r.withDO(r.DO.Scopes(funcs...))
}

func (r responseDo) Unscoped() IResponseDo {
	return r.withDO(r.DO.Unscoped())
}

func (r responseDo) Create(values ...*dbschema.Response) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Create(values)
}

func (r responseDo) CreateInBatches(values []*dbschema.Response, batchSize int) error {
	return r.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (r responseDo) Save(values ...*dbschema.Response) error {
	if len(values) == 0 {
		return nil
	}
	return r.DO.Save(values)
}

func (r responseDo) First() (*dbschema.Response, error) {
	if result, err := r.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*dbschema.Response), nil
	}
}

func (r responseDo) Take() (*dbschema.Response, error) {
	if result, err := r.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*dbschema.Response), nil
	}
}

func (r responseDo) Last() (*dbschema.Response, error) {
	if result, err := r.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*dbschema.Response), nil
	}
}

func (r responseDo) Find() ([]*dbschema.Response, error) {
	result, err := r.DO.Find()
	return result.([]*dbschema.Response), err
}

func (r responseDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*dbschema.Response, err error) {
	buf := make([]*dbschema.Response, 0, batchSize)
	err = r.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (r responseDo) FindInBatches(result *[]*dbschema.Response, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return r.DO.FindInBatches(result, batchSize, fc)
}

func (r responseDo) Attrs(attrs ...field.AssignExpr) IResponseDo {
	return r.withDO(r.DO.Attrs(attrs...))
}

func (r responseDo) Assign(attrs ...field.AssignExpr) IResponseDo {
	return r.withDO(r.DO.Assign(attrs...))
}

func (r responseDo) Joins(fields ...field.RelationField) IResponseDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Joins(_f))
	}
	return &r
}

func (r responseDo) Preload(fields ...field.RelationField) IResponseDo {
	for _, _f := range fields {
		r = *r.withDO(r.DO.Preload(_f))
	}
	return &r
}

func (r responseDo) FirstOrInit() (*dbschema.Response, error) {
	if result, err := r.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*dbschema.Response), nil
	}
}

func (r responseDo) FirstOrCreate() (*dbschema.Response, error) {
	if result, err := r.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*dbschema.Response), nil
	}
}

func (r responseDo) FindByPage(offset int, limit int) (result []*dbschema.Response, count int64, err error) {
	result, err = r.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = r.Offset(-1).Limit(-1).Count()
	return
}

func (r responseDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = r.Count()
	if err != nil {
		return
	}

	err = r.Offset(offset).Limit(limit).Scan(result)
	return
}

func (r responseDo) Scan(result interface{}) (err error) {
	return r.DO.Scan(result)
}

func (r responseDo) Delete(models ...*dbschema.Response) (result gen.ResultInfo, err error) {
	return r.DO.Delete(models)
}

func (r *responseDo) withDO(do gen.Dao) *responseDo {
	r.DO = *do.(*gen.DO)
	return r
}
